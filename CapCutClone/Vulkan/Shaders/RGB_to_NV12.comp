#version 450

layout(local_size_x = 16, local_size_y = 16) in;

// Input: RGB Image (RGBA8)
layout(binding = 0, rgba8) uniform readonly image2D inputImage;

// Output: NV12 Images
// Y Plane: R8UI (1 byte per pixel)
layout(binding = 1, r8ui) uniform writeonly uimage2D yPlane;

// UV Plane: RG8UI (2 bytes per pixel pair) - U in R, V in G
layout(binding = 2, rg8ui) uniform writeonly uimage2D uvPlane;

// Push constants for dimensions
layout(push_constant) uniform Constants {
    int width;
    int height;
} params;

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    
    if (pos.x >= params.width || pos.y >= params.height) {
        return;
    }

    // Read RGB pixel
    vec4 rgb = imageLoad(inputImage, pos);
    
    // Convert to YUV (BT.709 full range)
    // Formula matching standard FFmpeg:
    // Y = 0.299 * R + 0.587 * G + 0.114 * B
    // U = -0.169 * R - 0.331 * G + 0.5 * B + 0.5
    // V = 0.5 * R - 0.419 * G - 0.081 * B + 0.5
    
    float y = 0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b;
    float u = -0.169 * rgb.r - 0.331 * rgb.g + 0.5 * rgb.b + 0.5;
    float v = 0.5 * rgb.r - 0.419 * rgb.g - 0.081 * rgb.b + 0.5;

    // Scale to [0, 255]
    uint y_val = uint(y * 255.0);
    uint u_val = uint(u * 255.0);
    uint v_val = uint(v * 255.0);

    // Write Y pixel
    imageStore(yPlane, pos, uvec4(y_val, 0, 0, 0));

    // Write UV pixel (subsampled 4:2:0)
    // Only separate processing for even coordinates
    if (pos.x % 2 == 0 && pos.y % 2 == 0) {
        // Output coordinate for UV plane is (x/2, y/2)
        ivec2 uvPos = pos / 2;
        
        // Write U and V as RG components
        imageStore(uvPlane, uvPos, uvec4(u_val, v_val, 0, 0));
    }
}
